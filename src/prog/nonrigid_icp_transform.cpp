#include <fmt/format.h>

#include <algorithm>
#include <cxxopts.hpp>
#include <iostream>

#include "src/lib/io_utils.hpp"
#include "src/lib/profiler.hpp"
#include "src/lib/pt_cloud.hpp"
#include "src/lib/timer.hpp"

struct Params {
  std::string pc_in;
  std::string pc_out;
  std::string transform;
  long chunk_size;
  bool suppress_logging;
  bool profiling;
};

Params ParseUserInputs(int argc, char** argv);

int main(int argc, char** argv) {
  try {
    Params params = ParseUserInputs(argc, argv);

    auto& profiler = Profiler::Instance();

    Timer timer;
    if (!params.suppress_logging) {
      std::cout << "Start of \"nonrigid-icp-transform\"\n";
    }

    if (params.profiling) profiler.Start("A.01 Read input point cloud");
    if (!params.suppress_logging) {
      std::cout << fmt::format("Read input point cloud \"{}\"\n", params.pc_in);
    }
    auto X = ImportFileToMatrix(params.pc_in, false, false);
    if (!params.suppress_logging) {
      std::cout << fmt::format("  Input point cloud has {:d} points\n", X.rows());
    }
    if (params.profiling) profiler.Stop("A.01 Read input point cloud");

    // Iterate over chunks of the point cloud
    if (params.profiling) profiler.Start("A.02 Transformation of point cloud");
    using Index = Eigen::Index;
    Index total_rows = X.rows();
    Index chunk_size = static_cast<Index>(params.chunk_size);
    if (chunk_size <= 0) {
      std::cerr << fmt::format("Chunk size must be positive (got {:d})\n", params.chunk_size);
      return 1;
    }
    Index num_chunks = (total_rows + chunk_size - 1) / chunk_size;  // ceil division
    for (Index i = 0; i < total_rows; i += chunk_size) {
      if (!params.suppress_logging) {
        std::cout << fmt::format("Transforming point cloud chunk {:d}/{:d} ...\n",
                                 static_cast<long long>(i / chunk_size + 1),
                                 static_cast<long long>(num_chunks));
      }

      // Row indices
      Index first_row = i;
      Index last_row = (std::min)(i + chunk_size, total_rows);  // (std::min) to avoid macro issues
      auto row_indices = Eigen::seq(first_row, last_row - 1);

      // Transform points in chunk
      auto pc_mov_chunk{PtCloud(
          X(row_indices, {X.namedColIndex("x"), X.namedColIndex("y"), X.namedColIndex("z")}))};
      // TODO Currently the translation grid is read from file for each chunk. Read once and pass to
      // function.
      pc_mov_chunk.ImportTranslationGrids(params.transform);
      pc_mov_chunk.InitMatricesForUpdateXt();
      pc_mov_chunk.UpdateXt();

      // Update points
      X(row_indices, Eigen::all) = pc_mov_chunk.Xt();
    }
    if (params.profiling) profiler.Stop("A.02 Transformation of point cloud");

    if (params.profiling) profiler.Start("A.03 Write point cloud");
    if (!params.suppress_logging) {
      std::cout << fmt::format("Write transformed point cloud to file: \"{}\"\n", params.pc_out);
    }
    SaveMatrixToFile(X, params.pc_in, params.pc_out);
    if (params.profiling) profiler.Stop("A.03 Write point cloud");

    if (!params.suppress_logging) {
      std::cout << fmt::format("Finished \"nonrigid-icp-transform\" in {}!\n", timer);
    }

    if (params.profiling && !params.suppress_logging) profiler.PrintSummary();
  } catch (const std::exception& e) {
    std::cerr << "Caught exception: " << e.what() << std::endl;
    return 1;
  } catch (...) {
    std::cerr << "Caught unknown exception." << std::endl;
    return 1;
  }

  return 0;
}

Params ParseUserInputs(int argc, char** argv) {
  cxxopts::Options options("nonrigid-icp-transform",
                           "Transformation of point cloud using transform file generated by the "
                           "executable \"nonrigid-icp\"");

  // clang-format off
  options.add_options()
  ("i,pc_in",
   "Path to input point cloud",
   cxxopts::value<std::string>())
  ("o,pc_out",
   "Path to output point cloud, i.e. transformed point cloud",
   cxxopts::value<std::string>())
  ("t,transform",
   "Path to transform file generated by the executable \"nonrigid-icp\"",
   cxxopts::value<std::string>())
  ("c,chunk_size",
   "Number of points per chunk used for transforming the input point cloud",
   cxxopts::value<long>()->default_value("1000000"))
  ("s,suppress_logging",
   "Suppress log output",
   cxxopts::value<bool>()->default_value("false"))
  ("p,profiling",
    "Enable runtime profiling output (timing summary)",
    cxxopts::value<bool>()->default_value("false"))
  ("h,help",
   "Print usage");
  // clang-format on

  // Show help if no arguments are provided
  if (argc == 1) {
    std::cout << options.help() << std::endl;
    exit(0);
  }

  auto result = options.parse(argc, argv);

  if (result.count("help")) {
    std::cout << options.help() << std::endl;
    exit(0);
  }

  // Save to params
  Params params{};
  params.pc_in = result["pc_in"].as<std::string>();
  params.pc_out = result["pc_out"].as<std::string>();
  params.transform = result["transform"].as<std::string>();
  params.chunk_size = result["chunk_size"].as<long>();
  params.suppress_logging = result["suppress_logging"].as<bool>();
  params.profiling = result["profiling"].as<bool>();

  return params;
}
